Обход в ширину.
Составил и подготовил материал Дорти.
Обход в ширину подходит для поиска ближайщего "попадания" в точку.
aka Минимальное расстояние до точки.
на графе.
Также известен, как "BFS", не путатть с DFS 

Например:
____
А - Б - Г
    +   +
    В - Д
____
Обход в глубну путь А-Г может выдать
А-Б-В-Д-Г.
Хотя, данный метод не самый быстрый.
Самый быстрый - А-Б-Г.
Основан на том, что граф идёт "слоями".

Для реализации алгоритма мы перебираем граф "слоями".
Слой 1 - А.
Слой 2 - Б.
Слой 3 - В,Г.
Слой 4 - Д.
Т.е.:
Слой n содержит всех соседов точек из слоя n-1,
таких что, они не встречались в предыдущих слоях.
Если все точки встречались раньше, то в таком случае текущий 
слой n - последний слой. На этом стоит алгоритм заканчивать.
Количество слоёв соответственно - n в таком случае.
Также модно делать отчёт от 0, а не от 1.

Для реализации рекомендуется использовать "стек" - очередь.
Код реализации для c++:
____
#include <queue>
//
vector<int> graph[1000]; // Инициализируем Грапх
int dist[1000];
queue<int> q;
void bfs(int v){
for(int i=0;i<1000;i++){
dist[i]=-1;
} //Заполнить массив дист -1.

q.push(v);
while(!q.empty()){
int u = q.front(); 
q.pop();
for(int j=0;j<graph[u].size();++j){
int k = graph[u][j]; //Очередной сосед
if(dist[k] == -1) {
q.push(k);
dist[k] = dist[u] + 1;}

}

}

}